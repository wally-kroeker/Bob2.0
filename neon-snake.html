<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON SERPENT // CYBERPUNK EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --bg-color: #050510;
            --grid-line: #121225;
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #0aff00;
            --text-glow: 0 0 10px rgba(0, 243, 255, 0.7);
        }

        body {
            background-color: var(--bg-color);
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 4px;
        }

        canvas {
            background: radial-gradient(circle at center, #0a0a1a 0%, #000000 100%);
            display: block;
            border-radius: 4px;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.6;
        }
        
        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 20;
        }

        .hud-text {
            font-size: 1.2rem;
            text-shadow: var(--text-glow);
            letter-spacing: 2px;
        }

        #score-display {
            color: var(--neon-green);
        }

        #high-score-display {
            color: var(--neon-pink);
            text-align: right;
        }

        #menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
            backdrop-filter: blur(5px);
            transition: opacity 0.3s ease;
        }

        h1 {
            font-size: 4rem;
            margin: 0;
            background: linear-gradient(to right, var(--neon-blue), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 243, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 5px;
            animation: glitch 3s infinite;
        }

        .btn {
            margin-top: 40px;
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            background: transparent;
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 0 0 10px var(--neon-blue), inset 0 0 10px var(--neon-blue);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            pointer-events: auto;
        }

        .btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 30px var(--neon-blue), inset 0 0 20px var(--neon-blue);
            transform: scale(1.05);
        }

        .controls-hint {
            margin-top: 20px;
            font-size: 0.8rem;
            color: #aaa;
            text-shadow: none;
        }

        /* Glitch Animation Keyframes */
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        .hidden {
            opacity: 0;
            pointer-events: none !important;
        }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="scanlines"></div>
        
        <div id="ui-layer">
            <div id="score-display">SCORE: 0</div>
            <div id="high-score-display">HI-SCORE: 0</div>
        </div>

        <div id="menu-overlay">
            <h1 id="title-text">NEON SERPENT</h1>
            <button class="btn" id="start-btn">INITIALIZE</button>
            <div class="controls-hint">USE ARROW KEYS OR WASD TO MOVE</div>
        </div>
    </div>

    <script>
        /**
         * NEON SERPENT
         * A Cyberpunk reimagining of the classic Snake game.
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-display');
        const highScoreEl = document.getElementById('high-score-display');
        const menuOverlay = document.getElementById('menu-overlay');
        const startBtn = document.getElementById('start-btn');
        const titleText = document.getElementById('title-text');

        // --- Config ---
        const CELL_SIZE = 20;
        const GRID_WIDTH = canvas.width / CELL_SIZE;
        const GRID_HEIGHT = canvas.height / CELL_SIZE;
        const INITIAL_SPEED = 100;
        
        // --- State ---
        let gameLoopId;
        let lastTime = 0;
        let accumulator = 0;
        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food = { x: 0, y: 0 };
        let score = 0;
        let highScore = localStorage.getItem('neonSnakeHighScore') || 0;
        let particles = [];
        let isGameOver = false;
        let isPaused = false;
        let gameSpeed = INITIAL_SPEED;

        // Initialize High Score UI
        highScoreEl.innerText = `HI-SCORE: ${highScore}`;

        // --- Audio Context (Synthesized Sounds) ---
        // Using AudioContext to generate retro synth sounds without external assets
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'eat') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'die') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'move') {
                 // Very subtle click
                osc.type = 'square';
                osc.frequency.setValueAtTime(50, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.02, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.03);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.03);
            }
        }

        // --- Input Handling ---
        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    break;
            }
        });

        startBtn.addEventListener('click', startGame);

        // --- Game Logic ---

        function initGame() {
            snake = [
                { x: 10, y: 10 },
                { x: 9, y: 10 },
                { x: 8, y: 10 }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            gameSpeed = INITIAL_SPEED;
            isGameOver = false;
            particles = [];
            scoreEl.innerText = `SCORE: 0`;
            placeFood();
            menuOverlay.classList.add('hidden');
        }

        function startGame() {
            initGame();
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            lastTime = performance.now();
            accumulator = 0;
            requestAnimationFrame(gameLoop);
        }

        function placeFood() {
            let valid = false;
            while (!valid) {
                food.x = Math.floor(Math.random() * GRID_WIDTH);
                food.y = Math.floor(Math.random() * GRID_HEIGHT);
                
                valid = true;
                // Don't spawn on snake
                for (let part of snake) {
                    if (part.x === food.x && part.y === food.y) {
                        valid = false;
                        break;
                    }
                }
            }
        }

        function gameOver() {
            isGameOver = true;
            playSound('die');
            
            // Screen shake effect
            canvas.style.transform = 'translate(5px, 5px)';
            setTimeout(() => canvas.style.transform = 'translate(-5px, -5px)', 50);
            setTimeout(() => canvas.style.transform = 'translate(5px, -5px)', 100);
            setTimeout(() => canvas.style.transform = 'none', 150);

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('neonSnakeHighScore', highScore);
                highScoreEl.innerText = `HI-SCORE: ${highScore}`;
            }

            titleText.innerText = "SYSTEM FAILURE";
            startBtn.innerText = "REBOOT";
            menuOverlay.classList.remove('hidden');
        }

        function update(dt) {
            accumulator += dt;

            // Fixed time step for logic
            if (accumulator > gameSpeed) {
                accumulator -= gameSpeed;
                
                // Move Snake
                direction = nextDirection;
                const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

                // Collision with Walls
                if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT) {
                    gameOver();
                    return;
                }

                // Collision with Self
                for (let part of snake) {
                    if (head.x === part.x && head.y === part.y) {
                        gameOver();
                        return;
                    }
                }

                snake.unshift(head);

                // Eat Food
                if (head.x === food.x && head.y === food.y) {
                    score += 10;
                    scoreEl.innerText = `SCORE: ${score}`;
                    
                    // Create particles
                    createExplosion(food.x * CELL_SIZE + CELL_SIZE/2, food.y * CELL_SIZE + CELL_SIZE/2, '#ff00ff');
                    
                    playSound('eat');
                    placeFood();
                    
                    // Increase speed slightly up to a limit
                    if (gameSpeed > 50) gameSpeed -= 1;
                    
                } else {
                    snake.pop();
                    playSound('move'); // subtle click
                }
            }
            
            // Update Particles
            particles.forEach((p, index) => {
                p.life -= dt;
                p.x += p.vx * (dt / 16);
                p.y += p.vy * (dt / 16);
                if (p.life <= 0) particles.splice(index, 1);
            });
        }

        // --- Rendering ---

        function draw() {
            // Clear Background
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Grid
            ctx.strokeStyle = '#121225';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x <= canvas.width; x += CELL_SIZE) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for (let y = 0; y <= canvas.height; y += CELL_SIZE) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();

            // Draw Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });

            // Draw Food
            // Pulsing effect
            const pulse = Math.sin(Date.now() / 200) * 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = '#ff00ff';
            ctx.fillRect(
                food.x * CELL_SIZE + 2 - pulse/2, 
                food.y * CELL_SIZE + 2 - pulse/2, 
                CELL_SIZE - 4 + pulse, 
                CELL_SIZE - 4 + pulse
            );
            ctx.shadowBlur = 0;

            // Draw Snake
            snake.forEach((part, index) => {
                const isHead = index === 0;
                
                if (isHead) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00f3ff';
                    ctx.fillStyle = '#00f3ff';
                } else {
                    ctx.shadowBlur = 0;
                    // Gradient along body
                    const alpha = 1 - (index / snake.length);
                    ctx.fillStyle = `rgba(0, 243, 255, ${Math.max(0.3, alpha)})`;
                }

                ctx.fillRect(
                    part.x * CELL_SIZE + 1, 
                    part.y * CELL_SIZE + 1, 
                    CELL_SIZE - 2, 
                    CELL_SIZE - 2
                );
            });
            ctx.shadowBlur = 0; // Reset
        }

        // --- Particle System ---
        function createExplosion(x, y, color) {
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 500 + Math.random() * 300,
                    maxLife: 800,
                    color: color,
                    size: Math.random() * 3 + 1
                });
            }
        }

        // --- Game Loop ---
        function gameLoop(timestamp) {
            if (isGameOver) {
                return; // Stop loop on game over, wait for restart
            }

            const dt = timestamp - lastTime;
            lastTime = timestamp;

            update(dt);
            draw();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Initial Draw
        draw();

    </script>
</body>
</html>
